#!/usr/bin/env python

import sys
import subprocess
import os.path

class resolverTemplate:
    resolver = [
    'static void (*resolve_foo(void)) {',
    '    long hwcaps = getauxval(AT_HWCAP);',
    '    long hwcaps2 = getauxval(AT_HWCAP2);',
    '',
    '    if (hwcaps2 & HWCAP2_SVE2)',
    '        return foo_SVE2;',
    '    else if (hwcaps & HWCAP_SVE)',
    '        return foo_SVE;',
    '    else ',
    '        return foo_NonSVE;',
    '}',
    '',
    'void *foo() __attribute__((ifunc("resolve_foo")));',
    ]
    main = [
        'int main() {'
    ]

#GCC target pragmas
class pragmas:
    SVE2 = "#pragma GCC target \"march=armv8-a+sve2\""
    SVE = "#pragma GCC target \"march=armv8-a+sve\""
    NonSVE = "#pragma GCC target \"march=armv8-a\""

#color codes
class txtColors:
    FAIL = '\033[91m'
    WARNING = '\033[93m'
    GREEN = '\033[92m'
    STD = '\033[0m'

# Function suffixes
nonsve = '_NonSVE'
sve = '_SVE'
sve2 = '_SVE2'

class ifuncWriter:
    def __init__(self):
        self._resolvers = []
        self._main = resolverTemplate.main

    def __add__(self, functionName:str):
        resolver = ["//resolver for " + functionName]
        for line in resolverTemplate.resolver:
            line = line.replace("foo", functionName)
            resolver.append(line)
        self._resolvers.append(resolver)
        self.modifyMain(functionName)

    def modifyMain(self, functionName:str):
        self._main.append('    ' + functionName + '();')

    def getIfuncBits(self):
        self._main.append('}')
        ifuncBits = []
        for resolver in self._resolvers:
            for line in resolver:
                ifuncBits.append(line + '\n')
            ifuncBits.append('\n')
        ifuncBits.append('\n')
        for line in self._main:
            ifuncBits.append(line + '\n')


        return ifuncBits
#=====================================================================================================================================#

class functionConverter:
    def __init__(self, functLines:list):
        self._functName = ""
        self._returnType = ""
        self._functLines = functLines
        self.setFunctInfo()

    def setFunctInfo(self):
        declaration = self._functLines[0]

        declParts = declaration.split("(")
        declPts2 = declParts[0].split(" ")

        self._returnType = declPts2[0]
        self._functName = declPts2[1]

    def getNewFunction(self, avType:int):
        vectorizationSuffix = ""
        pragma = ""
        if avType == 1:
            vectorizationSuffix = nonsve
            pragma = pragmas.NonSVE
        elif avType == 2:
            vectorizationSuffix = sve
            pragma = pragmas.SVE
        elif avType == 3:
            vectorizationSuffix = sve2
            pragma = pragmas.SVE2
        else:
            print(txtColors.FAIL + "ERROR: getNewFunction received an invalid avType ID. Must be between 1-3" + txtColors.STD)
            sys.exit()
        
        return self.editFunction(vectorizationSuffix, pragma)

    def editFunction(self, vecSuf:str, pragma:str):
        nFunc = [""]
        nFunc[0] = pragma
        for line in self._functLines:
            nFunc.append(line)

        declaration = nFunc[1]
        declParts = declaration.split("(")
        
        declParts[0] = self._returnType + " *" + self._functName
        declParts[0] += vecSuf

        newDeclaration = declParts[0] + "(" + declParts[1]
        nFunc[1] = newDeclaration

        return nFunc
    
    def getOrigFunction(self):
        return self._functLines
#=====================================================================================================================================#

class autoVectorTool:
    def __init__(self, filename:str):
        self._filename = filename
        fNameParts = filename.split(".")
        self._newFile = fNameParts[0] + "_AVT." + fNameParts[1]
        self._ifuncBits = ifuncWriter()
        self._origContent = []
        self._functions = []
        self.setOrigContent()
        self.getFunctions()
        
    def run(self):
        for function in self._functions:
            self._ifuncBits + function._functName
        
        self.writeNewFunctFile()
        
    def writeNewFunctFile(self):
        with open (self._newFile, 'w') as file:
            file.write('#include <sys/auxv.h>\n')

            for function in self._functions:
                file.write('\n')
                file.write("//" + function._functName + "============================================//\n")
                for line in function.getNewFunction(1):
                    file.write(line + '\n')
                for line in function.getNewFunction(2):
                    file.write(line + '\n')
                for line in function.getNewFunction(3):
                    file.write(line + '\n')
            file.writelines(self._ifuncBits.getIfuncBits())

    def setOrigContent(self):
        try:
            with open (self._filename, 'r') as src:
                for line in src.read().splitlines():
                    self._origContent.append(line)
        except:            
            print(txtColors.FAIL + "\nERROR: Unable to retrieve file content from\"" + self._filename +  "\"\n")
            print(txtColors.WARNING + "Ensure that the file name is correct and that the file is in the current directory" + txtColors.STD) 

    def getFunctions(self):
        try:
            functionLines:list = []
            isFunctionLine = False
            openBrackets = 0
            for line in self._origContent:
                if isFunctionLine is False:
                    if "(" in line and "void" in line:
                        isFunctionLine = True
                        functionLines.append(line)
                    if "{" in line:
                        openBrackets += 1
                else:
                    if "{" in line:
                        openBrackets += 1
                        functionLines.append(line)
                    elif "}" in line:
                        openBrackets -= 1
                        functionLines.append(line)
                        if openBrackets == 0:
                            isFunctionLine = False
                            self._functions.append(functionConverter(functionLines))
                            functionLines = []
                    else:
                        functionLines.append(line)
        except:
            print(txtColors.FAIL + "\nERROR: Unable to retrieve function in file content for\"" + self._filename +  "\"\n")
            print(txtColors.WARNING + "Ensure that the file name is correct and that the file contains functions" + txtColors.STD)     

    def confirmNewFile(self):
        if os.path.exists(self._newFile):
            print(txtColors.GREEN + "fileToArray succesfully created" + "\'" + self._output + "\'" + txtColors.STD)
        else:
            print(txtColors.FAIL + "AVT unable to confirm " + self._output + " was sucessfully created." + txtColors.STD)

    def modifyMakefile(self):
        f = self._filename.split('.')
        searchStr = f[0]
        newMF = []
        nf = self._newFile.split('.')
        replacementStr = nf[0]
        try:
            with open("Makefile", 'r') as mf:
                origMF = mf.read().splitlines()
                for line in origMF:
                    if searchStr in line:
                        line = line.replace(searchStr, replacementStr)
                    newMF.append(line)
            with open("Makefile", 'w') as mf:
                for line in newMF:
                    mf.write(line + '\n')
        except:
            print(txtColors.FAIL + "Unable to modify Makefile.\n" + txtColors.WARNING + "Ensure that a Makefile is present in the current to be modified by AVT" + txtColors.STD)
#=====================================================================================================================================#

def printInvalidOptionsMessage():
    print(txtColors.FAIL + "Invalid options included in AVT call")
    print(txtColors.WARNING + "Use < py avt -h > to see available options" + txtColors.STD)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        raise Exception(txtColors.FAIL + 
        "To use the avt tool you must call it with a file like so:\n" + 
        txtColors.WARNING + "      " + "< py avt function.c >\n" +
        "OR       < py avt -h > in order to see optional commands" +
        txtColors.STD)
    elif len(sys.argv) < 3:
        if sys.argv[1] == '-h':
            print("AutoVectorTool options:")
            print(txtColors.GREEN + "\n-m   :   modify a makefile and call make after modifying" + txtColors.STD)
            print('')
            sys.exit()
        else:
            avt = autoVectorTool(sys.argv[1])
            avt.run()
            sys.exit()
    elif len(sys.argv) < 4:
        if sys.argv[2] == '-m':
            avt = autoVectorTool(sys.argv[1])
            avt.run()
            p = subprocess.Popen('make', stdout=subprocess.PIPE)
            for line in p.stdout:
                print(line)
            p.wait()
        else:
            printInvalidOptionsMessage()
    elif len(sys.argv) > 3:
       printInvalidOptionsMessage()
    else:
        printInvalidOptionsMessage()

